/**
 * Представим, что на одном из проектов нам потребовался DSL для решения бизнес-задачи. Наши пользователи - большие поклонники Lisp, поэтому синтаксис этого языка им более привычен, чем синтаксис JS.
 * Парсер оригинального синтаксиса Lisp нам написать хоть и не так сложно, но все же для MVP это может быть неразумно, а вот простенький интерпретатор нам точно будет полезен.
 *
 * Что мы хотим получить:
 * 1. Возможность объявлять функции таким образом: [defn, 'funcName', ['a', 'b'], ['sum', 'a', 'b']], где
 *      defn - ключевое слово для определения функции
 *      'funcName' - имя функции
 *      ['a', 'b'] - перечисление аргументов функции
 *      ['sum', 'a', 'b'] - тело функции (т. е. вызов функции sum с аргументами a и b)
 * 2. Соответственно вызов функции должен быть таким ['funcName', 'a', 'b']
 *
 * Ниже уже реализован некоторый runtime и есть пример вызова interpret. Необходимо имплементировать interpret и defn.
 *
 * P.S.
 * Даже если не получится выполнять задание в полной мере (например, где-то застряли), все равно скидывайте в качестве решения то, что получилось.
 */

const defn = (functionName, args, body) => {
  // требуется реализация

  // Создадим обьект из параметра body
  const b = new Object();
  let name = body[0];
  b.name = new Array(body[1], body[2], body[3]);
  
  // Создаем новый обьект из параметров
  const obj = {
    functionName: functionName,
    args: args,
    body: b,
  };

  const res = sum(10, 20, 30);
  return res;
};

const interpret = (...code) => {
  // требуется реализация
  const res = defn(code[0][1], code[0][2], code[1]);

  return res;
};

// Функция, используемая в runtime
const sum = (...args) => args.reduce((prev, curr) => prev + curr);

// Пример вызова функции interpret
const result = interpret(
  [defn, "sum3", ["a", "b", "c"], [sum, "a", "b", "c"]],
  ["sum3", 10, 20, 30]
);

console.log(result);
//console.assert(result === 60);
